// ============================================================================
// ملف Planet.cpp - تنفيذ كلاس الكوكب
// ============================================================================
// هذا الملف يحتوي على جميع الدوال التي تنفذ سلوك الكوكب في النظام الشمسي
// ============================================================================

// تضمين ملف تعريف كلاس الكوكب (يحتوي على تعريفات المتغيرات والدوال)
#include "../include/Planet.h"

// تضمين مكتبة OpenGL للرسومات ثلاثية الأبعاد
#include <GL/glut.h>

// تضمين مكتبة الرياضيات للدوال الرياضية (sin, cos, sqrt, atan2, etc.)
#include <math.h>

// تضمين مكتبة معالجة السلاسل النصية (للتعامل مع النصوص)
#include <cstring>

// ============================================================================
// ثوابت رياضية
// ============================================================================

// ثابت رياضي لقيمة π (باي) بدقة عالية جداً (32 رقم عشري)
// يُستخدم في جميع الحسابات الفلكية والهندسية
const double M_PI_CONST = 3.1415926535897932384626433832795;

// ============================================================================
// دالة البناء Constructor - تقوم بإنشاء كوكب جديد
// ============================================================================
// هذه الدالة تستدعى عند إنشاء كائن كوكب جديد
// تقوم بتهيئة جميع المتغيرات بالقيم الممررة إليها
// ============================================================================
Planet::Planet(
    double oRadius,      // نصف قطر المدار حول الشمس (المحور شبه الرئيسي)
    double oSpeed,       // سرعة الدوران حول الشمس (كلما زادت كلما كان أسرع)
    double sz,           // حجم الكوكب (نصف القطر)
    double rSpeed,       // سرعة الدوران حول المحور (دوران الكوكب حول نفسه)
    double r,            // قيمة اللون الأحمر (RGB) - من 0.0 إلى 1.0
    double g,            // قيمة اللون الأخضر (RGB) - من 0.0 إلى 1.0
    double b,            // قيمة اللون الأزرق (RGB) - من 0.0 إلى 1.0
    const char* n,       // اسم الكوكب (نص ثابت)
    int moonCount,       // عدد الأقمار التابعة للكوكب
    Moon* moonData,      // مؤشر إلى مصفوفة بيانات الأقمار (nullptr إذا لم يكن هناك أقمار)
    bool rings,          // هل للكوكب حلقات؟ (true = نعم، false = لا)
    double rInner,       // نصف القطر الداخلي للحلقات (إذا كان للكوكب حلقات)
    double rOuter,       // نصف القطر الخارجي للحلقات (إذا كان للكوكب حلقات)
    double rR,           // قيمة اللون الأحمر للحلقات (RGB)
    double rG,           // قيمة اللون الأخضر للحلقات (RGB)
    double rB,           // قيمة اللون الأزرق للحلقات (RGB)
    double ecc,          // الانحراف المركزي (eccentricity) - 0 = دائرة، >0 = إهليلجي
    double incl,         // الميل المداري (orbital inclination) بالدرجات
    double tilt,         // الميل المحوري (axial tilt) بالدرجات
    double lonPeri)      // زاوية طول الحضيض (longitude of perihelion) بالدرجات
    // قائمة التهيئة: تهيئة المتغيرات مباشرة قبل دخول جسم الدالة
    : orbitRadius(oRadius),           // تهيئة نصف قطر المدار
      orbitSpeed(oSpeed),              // تهيئة سرعة الدوران حول الشمس
      size(sz),                        // تهيئة حجم الكوكب
      rotationSpeed(rSpeed),            // تهيئة سرعة الدوران حول المحور
      rotation(0.0),                   // تهيئة زاوية الدوران الحالية (تبدأ من 0)
      name(n),                         // تهيئة اسم الكوكب
      numMoons(moonCount),             // تهيئة عدد الأقمار
      hasRings(rings),                 // تهيئة وجود الحلقات
      ringInnerRadius(rInner),         // تهيئة نصف القطر الداخلي للحلقات
      ringOuterRadius(rOuter),         // تهيئة نصف القطر الخارجي للحلقات
      eccentricity(ecc),               // تهيئة الانحراف المركزي
      orbitalInclination(incl),        // تهيئة الميل المداري
      axialTilt(tilt),                 // تهيئة الميل المحوري
      longitudeOfPerihelion(lonPeri)  // تهيئة زاوية طول الحضيض
{
    // ========================================================================
    // تعيين لون الكوكب في مصفوفة الألوان
    // ========================================================================
    color[0] = r;  // تعيين قيمة اللون الأحمر (0.0 = أسود، 1.0 = أحمر كامل)
    color[1] = g;  // تعيين قيمة اللون الأخضر (0.0 = أسود، 1.0 = أخضر كامل)
    color[2] = b;  // تعيين قيمة اللون الأزرق (0.0 = أسود، 1.0 = أزرق كامل)
    
    // ========================================================================
    // نسخ بيانات الأقمار من المصفوفة الممررة إلى مصفوفة داخلية
    // ========================================================================
    if (moonCount > 0 && moonData != nullptr) {  // إذا كان هناك أقمار وبيانات صحيحة
        moons = new Moon[moonCount];              // إنشاء مصفوفة ديناميكية للأقمار
        for (int i = 0; i < moonCount; i++) {    // نسخ كل قمر من المصفوفة الممررة
            moons[i] = moonData[i];               // نسخ بيانات القمر الحالي
        }
    } else {                                      // إذا لم يكن هناك أقمار
        moons = nullptr;                          // تعيين المؤشر إلى nullptr (لا يوجد أقمار)
    }
    
    // ========================================================================
    // تعيين لون الحلقات (إذا كان للكوكب حلقات)
    // ========================================================================
    if (hasRings) {                               // إذا كان للكوكب حلقات
        ringColor[0] = rR;                        // تعيين اللون الأحمر للحلقات
        ringColor[1] = rG;                        // تعيين اللون الأخضر للحلقات
        ringColor[2] = rB;                        // تعيين اللون الأزرق للحلقات
    }
}

// ============================================================================
// دالة الإتلاف Destructor - تقوم بحذف الكوكب من الذاكرة
// ============================================================================
// هذه الدالة تستدعى تلقائياً عند حذف الكوكب
// تقوم بتحرير الذاكرة المخصصة للأقمار
// ============================================================================
Planet::~Planet() {
    if (moons != nullptr) {  // إذا كان هناك أقمار
        delete[] moons;       // حذف مصفوفة الأقمار من الذاكرة
    }
}

// ============================================================================
// دوال Getter - لإرجاع قيم خصائص الكوكب
// ============================================================================
// هذه الدوال تسمح بالوصول إلى القيم الخاصة (private) من خارج الكلاس
// ============================================================================

// إرجاع نصف قطر المدار حول الشمس
double Planet::getOrbitRadius() const { return orbitRadius; }

// إرجاع سرعة الدوران حول الشمس
double Planet::getOrbitSpeed() const { return orbitSpeed; }

// إرجاع حجم الكوكب (نصف القطر)
double Planet::getSize() const { return size; }

// إرجاع اسم الكوكب
const char* Planet::getName() const { return name; }

// ============================================================================
// دالة رسم مسار المدار الإهليلجي - ترسم مسار الكوكب حول الشمس
// ============================================================================
// هذه الدالة ترسم خطاً يوضح مسار الكوكب حول الشمس
// المسار يكون على شكل قطع ناقص (إهليلجي) وليس دائرة
// ============================================================================
void Planet::drawOrbitPath() {
    // إيقاف الإضاءة مؤقتاً لرسم الخط بلون ثابت (بدون تأثيرات الإضاءة)
    glDisable(GL_LIGHTING);
    
    // تعيين لون رمادي داكن للمسار (RGB: 0.2, 0.2, 0.25)
    glColor3f(0.2f, 0.2f, 0.25f);
    
    // تعيين سمك الخط إلى 1 بكسل
    glLineWidth(1.0f);
    
    // حفظ المصفوفة الحالية (لإمكانية استعادتها لاحقاً)
    glPushMatrix();
    
    // تطبيق الميل المداري (إمالة المدار بزاوية معينة حول المحور X)
    // orbitalInclination: الزاوية بالدرجات التي يميل بها المدار عن المستوى المرجعي
    glRotatef((float)orbitalInclination, 1.0f, 0.0f, 0.0f);
    
    // تدوير المدار بزاوية طول الحضيض حول المحور Y
    // longitudeOfPerihelion: الزاوية التي تحدد اتجاه الحضيض (أقرب نقطة للشمس)
    glRotatef((float)longitudeOfPerihelion, 0.0f, 1.0f, 0.0f);
    
    // ========================================================================
    // حساب أبعاد القطع الناقص (الإهليلج)
    // ========================================================================
    double a = orbitRadius;  // المحور شبه الرئيسي (a) = نصف قطر المدار
    // المحور شبه الثانوي (b) = a * sqrt(1 - e²)
    // حيث e هو الانحراف المركزي
    double b = orbitRadius * sqrt(1.0 - eccentricity * eccentricity);
    
    // بدء رسم حلقة مغلقة من الخطوط (GL_LINE_LOOP يرسم خطاً مغلقاً)
    glBegin(GL_LINE_LOOP);
    
    // رسم 200 نقطة لتشكيل مدار إهليلجي بدقة عالية
    // كلما زاد عدد النقاط، كلما كان الشكل أكثر نعومة
    for (int i = 0; i < 200; i++) {
        // حساب الزاوية لكل نقطة (360 درجة مقسمة على 200)
        // تحويل الزاوية من 0 إلى 2π (من 0 إلى 360 درجة)
        double angle = 2.0 * M_PI_CONST * i / 200.0;
        
        // استخدام معادلة القطع الناقص البارامترية:
        // x = a * cos(θ) - a * e  (الإزاحة -a*e تضع الشمس في البؤرة وليس المركز)
        // z = b * sin(θ)
        double x = a * cos(angle) - a * eccentricity;  // الموضع X مع إزاحة البؤرة
        double z = b * sin(angle);                      // الموضع Z
        
        // رسم النقطة الحالية في الفضاء ثلاثي الأبعاد
        glVertex3f((float)x, 0.0f, (float)z);
    }
    glEnd();  // إنهاء رسم الخط
    
    // استعادة المصفوفة السابقة (إلغاء التحويلات المطبقة)
    glPopMatrix();
    
    // إعادة تفعيل الإضاءة للعناصر الأخرى
    glEnable(GL_LIGHTING);
}

// ============================================================================
// دالة حل معادلة كبلر باستخدام Newton-Raphson (أسرع وأدق)
// ============================================================================
// معادلة كبلر: M = E - e * sin(E)
// حيث:
//   M = الشذوذ المتوسط (Mean Anomaly) = n * t
//   E = الشذوذ اللامركزي (Eccentric Anomaly) - المجهول الذي نريد إيجاده
//   e = الانحراف المركزي (Eccentricity)
// ============================================================================
double solveKeplerEquation(double M, double e) {
    double E = M;                    // القيمة الأولية للتخمين (نبدأ من M)
    const double tolerance = 1e-10; // دقة عالية جداً (0.0000000001)
    const int maxIterations = 20;    // الحد الأقصى لعدد التكرارات
    
    // حل المعادلة باستخدام طريقة Newton-Raphson
    for (int i = 0; i < maxIterations; i++) {
        // حساب قيمة الدالة: f(E) = E - e*sin(E) - M
        // نريد أن تكون هذه القيمة = 0
        double f = E - e * sin(E) - M;
        
        // حساب مشتقة الدالة: f'(E) = 1 - e*cos(E)
        double fPrime = 1.0 - e * cos(E);
        
        // تجنب القسمة على صفر (إذا كانت المشتقة صغيرة جداً)
        if (fabs(fPrime) < 1e-10) break;
        
        // حساب التصحيح: delta = f(E) / f'(E)
        // هذه هي صيغة Newton-Raphson
        double delta = f / fPrime;
        
        // تحديث القيمة: E_new = E_old - delta
        E -= delta;
        
        // إذا كان التصحيح صغيراً جداً، وصلنا للدقة المطلوبة
        if (fabs(delta) < tolerance) break;
    }
    
    // إرجاع القيمة المحسوبة للشذوذ اللامركزي
    return E;
}

// ============================================================================
// دالة رسم الكوكب - ترسم الكوكب في موقعه الحالي بناءً على الوقت
// ============================================================================
// هذه الدالة الرئيسية لرسم الكوكب
// تحسب موقعه بناءً على الوقت الحالي وتقوم برسمه مع أقماره وحلقاته
// ============================================================================
void Planet::draw(double time) {
    // ========================================================================
    // حساب موقع الكوكب على المدار باستخدام قوانين كبلر
    // ========================================================================
    
    // حساب الشذوذ المتوسط (Mean Anomaly)
    // = الوقت × سرعة الدوران حول الشمس
    double meanAnomaly = time * orbitSpeed;
    
    // استخدام Newton-Raphson لحل معادلة كبلر (أسرع وأدق من التكرار البسيط)
    // للحصول على الشذوذ اللامركزي (Eccentric Anomaly)
    double E = solveKeplerEquation(meanAnomaly, eccentricity);
    
    // حساب الشذوذ الحقيقي (True Anomaly) - الزاوية الحقيقية من الحضيض
    // هذه هي الزاوية التي تحدد موقع الكوكب على المدار
    double trueAnomaly = 2.0 * atan2(
        sqrt(1.0 + eccentricity) * sin(E / 2.0),  // البسط
        sqrt(1.0 - eccentricity) * cos(E / 2.0)    // المقام
    );
    
    // حساب المسافة من الشمس باستخدام معادلة القطع الناقص القطبية
    // r = a(1-e²) / (1 + e*cos(ν))
    // حيث:
    //   a = المحور شبه الرئيسي (orbitRadius)
    //   e = الانحراف المركزي
    //   ν = الشذوذ الحقيقي (trueAnomaly)
    double r = orbitRadius * (1.0 - eccentricity * eccentricity) / 
              (1.0 + eccentricity * cos(trueAnomaly));
    
    // رسم مسار المدار الإهليلجي (خط يوضح مسار الكوكب)
    drawOrbitPath();
    
    // حفظ المصفوفة الحالية (لإمكانية استعادتها لاحقاً)
    glPushMatrix();
    
    // ========================================================================
    // تطبيق التحويلات الهندسية لوضع الكوكب في موقعه الصحيح
    // ========================================================================
    
    // 1. تطبيق الميل المداري (إمالة المدار حول المحور X)
    glRotatef((float)orbitalInclination, 1.0f, 0.0f, 0.0f);
    
    // 2. تطبيق زاوية طول الحضيض (تدوير المدار حول المحور Y)
    glRotatef((float)longitudeOfPerihelion, 0.0f, 1.0f, 0.0f);
    
    // 3. حساب الموضع على المدار باستخدام الشذوذ الحقيقي
    double x = r * cos(trueAnomaly);  // الموضع X
    double z = r * sin(trueAnomaly);  // الموضع Z (Y = 0 في المستوى المداري)
    
    // 4. نقل الكوكب إلى موقعه على المدار
    glTranslatef((float)x, 0.0f, (float)z);
    
    // 5. تطبيق الميل المحوري (إمالة محور دوران الكوكب)
    glRotatef((float)axialTilt, 0.0f, 0.0f, 1.0f);
    
    // 6. تحديث زاوية الدوران حول المحور (دوران الكوكب حول نفسه)
    rotation += rotationSpeed * 0.5;  // زيادة الزاوية بناءً على السرعة والوقت
    
    // 7. تطبيق الدوران حول المحور Y (دوران الكوكب حول نفسه)
    glRotatef((float)rotation, 0.0f, 1.0f, 0.0f);
    
    // ========================================================================
    // رسم الحلقات (إذا كان للكوكب حلقات)
    // ========================================================================
    if (hasRings) {
        drawRings();  // استدعاء دالة رسم الحلقات
    }
    
    // ========================================================================
    // رسم الكوكب نفسه
    // ========================================================================
    
    // تعيين لون الكوكب (RGB)
    glColor3d(color[0], color[1], color[2]);
    
    // رسم الكوكب الأساسي ككرة صلبة
    // glutSolidSphere(radius, slices, stacks)
    //   radius: نصف القطر
    //   slices: عدد الشرائح الأفقية (40 = دقة عالية)
    //   stacks: عدد الشرائح العمودية (40 = دقة عالية)
    glutSolidSphere((float)size, 40, 40);
    
    // ========================================================================
    // إضافة تأثير الغلاف الجوي للكواكب الكبيرة
    // ========================================================================
    if (size > 1.5) {  // إذا كان حجم الكوكب أكبر من 1.5 (كواكب عملاقة)
        // تفعيل الشفافية (Blending) لرسم طبقة شفافة
        glEnable(GL_BLEND);
        
        // تحديد طريقة دمج الألوان الشفافة
        // GL_SRC_ALPHA: استخدام قيمة الشفافية من المصدر
        // GL_ONE_MINUS_SRC_ALPHA: استخدام (1 - الشفافية) للخلفية
        glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
        
        // إيقاف كتابة العمق (Depth Mask) للسماح بتداخل الطبقات
        glDepthMask(GL_FALSE);
        
        // رسم طبقة غلاف جوي رقيقة حول الكوكب
        // اللون: نفس لون الكوكب مع شفافية 15% (0.15)
        glColor4f((float)color[0], (float)color[1], (float)color[2], 0.15f);
        
        // رسم كرة أكبر قليلاً (5% أكبر) لتمثيل الغلاف الجوي
        glutSolidSphere((float)(size * 1.05), 35, 35);
        
        // إعادة تفعيل كتابة العمق
        glDepthMask(GL_TRUE);
        
        // إيقاف الشفافية
        glDisable(GL_BLEND);
    }
    
    // رسم اسم الكوكب فوقه
    drawText(0.0, size + 0.5, 0.0, name);
    
    // ========================================================================
    // رسم الأقمار (إذا كان للكوكب أقمار)
    // ========================================================================
    if (numMoons > 0) {
        drawMoons(time);  // استدعاء دالة رسم الأقمار
    }
    
    // استعادة المصفوفة السابقة (إلغاء جميع التحويلات المطبقة)
    glPopMatrix();
}

// ============================================================================
// دالة للحصول على موقع الكوكب في وقت معين
// ============================================================================
// هذه الدالة تحسب موقع الكوكب في الفضاء ثلاثي الأبعاد في وقت محدد
// تُستخدم لتحديد موقع الكوكب للكاميرا أو للحسابات الأخرى
// ============================================================================
void Planet::getPosition(double time, double& x, double& y, double& z) {
    // حساب الشذوذ المتوسط (Mean Anomaly)
    double meanAnomaly = time * orbitSpeed;
    
    // استخدام Newton-Raphson لحل معادلة كبلر
    double E = solveKeplerEquation(meanAnomaly, eccentricity);
    
    // حساب الشذوذ الحقيقي (True Anomaly)
    double trueAnomaly = 2.0 * atan2(
        sqrt(1.0 + eccentricity) * sin(E / 2.0),
        sqrt(1.0 - eccentricity) * cos(E / 2.0)
    );
    
    // حساب المسافة من الشمس
    double r = orbitRadius * (1.0 - eccentricity * eccentricity) / 
              (1.0 + eccentricity * cos(trueAnomaly));
    
    // حساب الموضع في المستوى المداري (قبل تطبيق الميل)
    double localX = r * cos(trueAnomaly);  // الموضع X في المستوى المداري
    double localZ = r * sin(trueAnomaly);  // الموضع Z في المستوى المداري
    
    // تحويل الزوايا من درجات إلى راديان
    double inclinationRad = orbitalInclination * M_PI_CONST / 180.0;      // الميل المداري بالراديان
    double lonPeriRad = longitudeOfPerihelion * M_PI_CONST / 180.0;       // زاوية طول الحضيض بالراديان
    
    // تطبيق التحويلات ثلاثية الأبعاد للحصول على الموضع النهائي
    // هذه التحويلات تأخذ في الاعتبار الميل المداري وزاوية طول الحضيض
    x = localX * cos(lonPeriRad) - localZ * sin(lonPeriRad);              // الموضع X النهائي
    y = localZ * sin(inclinationRad);                                      // الموضع Y النهائي (الارتفاع)
    z = localX * sin(lonPeriRad) + localZ * cos(lonPeriRad) * cos(inclinationRad);  // الموضع Z النهائي
}

// ============================================================================
// دالة لرسم نص في الفضاء ثلاثي الأبعاد
// ============================================================================
// هذه الدالة ترسم اسم الكوكب في الفضاء ثلاثي الأبعاد
// ============================================================================
void Planet::drawText(double x, double y, double z, const char* text) {
    // إيقاف الإضاءة لرسم النص بوضوح (بدون تأثيرات الإضاءة)
    glDisable(GL_LIGHTING);
    
    // تعيين اللون الأبيض للنص (RGB: 1.0, 1.0, 1.0)
    glColor3f(1.0f, 1.0f, 1.0f);
    
    // تحديد موقع بدء رسم النص في الفضاء ثلاثي الأبعاد
    glRasterPos3f((float)x, (float)y, (float)z);
    
    // المرور على كل حرف في النص ورسمه
    while (*text) {  // طالما لم نصل لنهاية النص
        // رسم الحرف الحالي بخط Helvetica حجم 12
        glutBitmapCharacter(GLUT_BITMAP_HELVETICA_12, *text);
        
        // الانتقال للحرف التالي في النص
        text++;
    }
    
    // إعادة تفعيل الإضاءة للعناصر الأخرى
    glEnable(GL_LIGHTING);
}

// ============================================================================
// دالة رسم الأقمار
// ============================================================================
// هذه الدالة ترسم جميع الأقمار التابعة للكوكب
// كل قمر يدور حول الكوكب في مدار دائري
// ============================================================================
void Planet::drawMoons(double time) {
    // المرور على كل قمر في المصفوفة
    for (int i = 0; i < numMoons; i++) {
        // حساب زاوية القمر على مداره
        // = الوقت × سرعة القمر + زاوية البداية
        double moonAngle = time * moons[i].speed + moons[i].initialAngle;
        
        // حساب موضع القمر على مداره الدائري
        double moonX = moons[i].orbitRadius * cos(moonAngle);  // الموضع X
        double moonZ = moons[i].orbitRadius * sin(moonAngle);  // الموضع Z
        
        // حفظ المصفوفة الحالية
        glPushMatrix();
        
        // نقل القمر إلى موقعه حول الكوكب
        glTranslatef((float)moonX, 0.0f, (float)moonZ);
        
        // تعيين لون القمر (RGB)
        glColor3d(moons[i].color[0], moons[i].color[1], moons[i].color[2]);
        
        // رسم القمر ككرة صلبة
        // 20 شريحة = دقة متوسطة (كافية للأقمار الصغيرة)
        glutSolidSphere((float)moons[i].size, 20, 20);
        
        // استعادة المصفوفة السابقة
        glPopMatrix();
    }
}

// ============================================================================
// دالة رسم الحلقات
// ============================================================================
// هذه الدالة ترسم حلقات الكوكب (مثل حلقات زحل)
// الحلقات تُرسم كحلقات شفافة متداخلة
// ============================================================================
void Planet::drawRings() {
    // إيقاف الإضاءة لرسم الحلقات بلون ثابت
    glDisable(GL_LIGHTING);
    
    // تفعيل الشفافية (Blending) لرسم الحلقات الشفافة
    glEnable(GL_BLEND);
    
    // تحديد طريقة دمج الألوان الشفافة
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
    
    // رسم 3 حلقات متداخلة (للحصول على تأثير واقعي)
    for (int j = 0; j < 3; j++) {
        // حساب نصف القطر الداخلي للحلقة الحالية
        // تقسيم المسافة بين الداخلي والخارجي إلى 3 أجزاء متساوية
        double innerRadius = ringInnerRadius + j * (ringOuterRadius - ringInnerRadius) / 3.0;
        
        // حساب نصف القطر الخارجي للحلقة الحالية
        double outerRadius = ringInnerRadius + (j + 1) * (ringOuterRadius - ringInnerRadius) / 3.0;
        
        // حساب الشفافية للحلقة (تقل تدريجياً للحلقات الخارجية)
        double alpha = 0.8 - j * 0.15;  // الحلقة الأولى: 0.8، الثانية: 0.65، الثالثة: 0.5
        
        // تعيين لون الحلقة مع الشفافية (RGBA)
        glColor4d(ringColor[0], ringColor[1], ringColor[2], alpha);
        
        // بدء رسم شريط من المربعات (QUAD_STRIP) لتشكيل الحلقة
        glBegin(GL_QUAD_STRIP);
        
        // رسم 100 نقطة لتشكيل دائرة ناعمة
        for (int i = 0; i <= 100; i++) {
            // حساب الزاوية لكل نقطة (360 درجة)
            double theta = 2.0 * M_PI_CONST * i / 100.0;
            
            // حساب قيم الجيب وجيب التمام (لتوفير الحسابات)
            double cosTheta = cos(theta);
            double sinTheta = sin(theta);
            
            // رسم نقطة على الحافة الداخلية للحلقة
            glVertex3f((float)(innerRadius * cosTheta), 0.0f, (float)(innerRadius * sinTheta));
            
            // رسم نقطة على الحافة الخارجية للحلقة
            glVertex3f((float)(outerRadius * cosTheta), 0.0f, (float)(outerRadius * sinTheta));
        }
        glEnd();  // إنهاء رسم الحلقة
    }
    
    // إيقاف الشفافية
    glDisable(GL_BLEND);
    
    // إعادة تفعيل الإضاءة
    glEnable(GL_LIGHTING);
}
